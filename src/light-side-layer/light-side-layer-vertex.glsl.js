export default `\
#define SHADER_NAME light-side-layer-vertex

attribute vec3 instancePositions;
attribute vec3 nextPositions;
attribute vec3 instancePositions64Low;
attribute vec3 nextPositions64Low;
attribute float instanceElevations;
attribute vec4 instanceFillColors;
attribute vec3 instancePickingColors;
attribute float instanceSpeed;

// main
attribute vec3 vertexPositions;
attribute float vertexValid;

uniform float opacity;
uniform float currentTime;

varying vec4 vColor;
varying float isValid;
varying float z;

uniform float x;
uniform float y;
uniform vec2 heightPosition;
uniform bool isTexture;
uniform bool animate;
uniform float baseRatio;
uniform float topRatio;
varying vec2 vUV;

struct PolygonProps {
    vec4 fillColors;
    vec4 lineColors;
    vec3 positions;
    vec3 nextPositions;
    vec3 pickingColors;
    vec3 positions64Low;
    vec3 nextPositions64Low;
    float elevations;
};

vec3 project_offset_normal(vec3 vector) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
        // normals generated by the polygon tesselator are in lnglat offsets instead of meters
        return normalize(vector * project_uCommonUnitsPerWorldUnit);
    }
    return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
    vec3 pos;
    vec3 pos64Low;
    vec3 normal;
    vec4 colors = props.fillColors;
  
    geometry.worldPosition = props.positions;
    geometry.worldPositionAlt = props.nextPositions;
    geometry.pickingColor = props.pickingColors;
  
    pos = mix(props.positions, props.nextPositions, vertexPositions.x);
    pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);
    isValid = vertexValid;

    
    pos.z += props.elevations * vertexPositions.z;
    z = pos.z;
    gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
    
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  
    vColor = vec4(colors.rgb, colors.a * opacity);
    
    DECKGL_FILTER_COLOR(vColor, geometry);
  }

void main(void) {
    float dis;
    float offset;
    PolygonProps props;

    props.positions = instancePositions;
    props.positions64Low = instancePositions64Low;
    props.elevations = instanceElevations;
    props.fillColors = instanceFillColors;
    props.pickingColors = instancePickingColors;
    props.nextPositions = nextPositions;
    props.nextPositions64Low = nextPositions64Low;
    
    calculatePosition(props);
    if(animate){
        if(isTexture) {
            offset = mod( currentTime * instanceSpeed, 5000.0) / 5000.0  * x;
            dis = distance(project_position(instancePositions.xy), project_position(nextPositions.xy)) / project_uCommonUnitsPerMeter.z;
            vUV = vec2( (mix(dis, 0.0, vertexPositions.x) - offset ) / x , z / y);
        }
    }
    vColor.a = (1.0 - (z - (instanceElevations * baseRatio) ) / (instanceElevations * (topRatio - baseRatio))) * opacity;
}
`;