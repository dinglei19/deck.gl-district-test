export default "#define SHADER_NAME light-side-layer-vertex\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec3 instancePickingColors;\nattribute float instanceSpeed;\n\n// main\nattribute vec3 vertexPositions;\nattribute float vertexValid;\n\nuniform float opacity;\nuniform float currentTime;\n\nvarying vec4 vColor;\nvarying float isValid;\nvarying float z;\n\nuniform float x;\nuniform float y;\nuniform vec2 heightPosition;\nuniform bool isTexture;\nuniform bool animate;\nuniform float baseRatio;\nuniform float topRatio;\nvarying vec2 vUV;\n\nstruct PolygonProps {\n    vec4 fillColors;\n    vec4 lineColors;\n    vec3 positions;\n    vec3 nextPositions;\n    vec3 pickingColors;\n    vec3 positions64Low;\n    vec3 nextPositions64Low;\n    float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n        project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n        // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n        return normalize(vector * project_uCommonUnitsPerWorldUnit);\n    }\n    return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n    vec3 pos;\n    vec3 pos64Low;\n    vec3 normal;\n    vec4 colors = props.fillColors;\n  \n    geometry.worldPosition = props.positions;\n    geometry.worldPositionAlt = props.nextPositions;\n    geometry.pickingColor = props.pickingColors;\n  \n    pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n    pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n    isValid = vertexValid;\n\n    \n    pos.z += props.elevations * vertexPositions.z;\n    z = pos.z;\n    gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n    \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  \n    vColor = vec4(colors.rgb, colors.a * opacity);\n    \n    DECKGL_FILTER_COLOR(vColor, geometry);\n  }\n\nvoid main(void) {\n    float dis;\n    float offset;\n    PolygonProps props;\n\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.elevations = instanceElevations;\n    props.fillColors = instanceFillColors;\n    props.pickingColors = instancePickingColors;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n    \n    calculatePosition(props);\n    if(animate){\n        if(isTexture) {\n            offset = mod( currentTime * instanceSpeed, 5000.0) / 5000.0  * x;\n            dis = distance(project_position(instancePositions.xy), project_position(nextPositions.xy)) / project_uCommonUnitsPerMeter.z;\n            vUV = vec2( (mix(dis, 0.0, vertexPositions.x) - offset ) / x , z / y);\n        }\n    }\n    vColor.a = (1.0 - (z - (instanceElevations * baseRatio) ) / (instanceElevations * (topRatio - baseRatio))) * opacity;\n}\n";